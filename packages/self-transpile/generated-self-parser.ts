import type { Parser } from "tpeg-core";import { capture, charClass, choice, literal, memoize, oneOrMore, optional, sequence, zeroOrMore } from "tpeg-core";
/**
 * Generated TPEG Parser: TPEGSelf
 * 
 * This file was automatically generated from a TPEG grammar.
 * Do not edit this file directly - regenerate from the grammar instead.
 */
export const self_grammar_definition: Parser<any> = memoize(sequence(literal("grammar"), self_identifier, literal("{"), self_rule_list, literal("}")));
// contains recursionexport const self_rule_list: Parser<any> = memoize(zeroOrMore(self_rule_definition));
// contains recursionexport const self_rule_definition: Parser<any> = memoize(sequence(self_identifier, literal("="), self_expression));
// contains recursionexport const self_expression: Parser<any> = memoize(self_choice_expr);
// contains recursionexport const self_choice_expr: Parser<any> = memoize(sequence(self_sequence_expr, zeroOrMore(sequence(literal("/"), self_sequence_expr))));
// contains recursionexport const self_sequence_expr: Parser<any> = memoize(zeroOrMore(self_labeled_expr));
// contains recursionexport const self_labeled_expr: Parser<any> = memoize(choice(sequence(capture("label", self_identifier), literal(":"), capture("expr", self_postfix_expr)), self_postfix_expr));
// contains recursionexport const self_postfix_expr: Parser<any> = memoize(sequence(self_primary_expr, optional(self_repetition_op)));
// contains recursionexport const self_primary_expr: Parser<any> = memoize(choice(self_string_literal, self_character_class, self_identifier, self_any_char, self_group_expr));
// contains recursionexport const self_group_expr: Parser<any> = memoize(sequence(literal("("), self_expression, literal(")")));
// contains recursionexport const self_repetition_op: Parser<any> = memoize(choice(literal("*"), literal("+"), literal("?"), self_quantified_op));
// contains recursionexport const self_quantified_op: Parser<any> = memoize(sequence(literal("{"), self_number, optional(sequence(literal(","), optional(self_number))), literal("}")));
// contains recursionexport const self_string_literal: Parser<any> = memoize(choice(self_double_quoted, self_single_quoted));
// contains recursionexport const self_double_quoted: Parser<any> = memoize(sequence(literal("\""), self_string_content, literal("\"")));
// contains recursionexport const self_single_quoted: Parser<any> = memoize(sequence(literal("'"), self_string_content, literal("'")));
// contains recursionexport const self_string_content: Parser<any> = zeroOrMore(charClass([""", "'"], true));
export const self_character_class: Parser<any> = memoize(sequence(literal("["), self_char_content, literal("]")));
// contains recursionexport const self_char_content: Parser<any> = zeroOrMore(charClass(["]"], true));
export const self_any_char: Parser<any> = literal(".");
export const self_identifier: Parser<any> = memoize(sequence(self_ident_start, zeroOrMore(self_ident_continue)));
// contains recursionexport const self_ident_start: Parser<any> = charClass([{ from: "a", to: "z" }, { from: "A", to: "Z" }, "_"]);
export const self_ident_continue: Parser<any> = charClass([{ from: "a", to: "z" }, { from: "A", to: "Z" }, { from: "0", to: "9" }, "_"]);
export const self_number: Parser<any> = oneOrMore(charClass([{ from: "0", to: "9" }]));
export const self_whitespace: Parser<any> = zeroOrMore(charClass([" ", "	", "
", ""]));
