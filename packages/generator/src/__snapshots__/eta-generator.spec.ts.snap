// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for simple grammar 1`] = `
"import type { Parser } from "tpeg-core";import { charClass, literal } from "tpeg-core";
export const test_hello: Parser<any> = literal("world");
export const test_number: Parser<any> = charClass([{ from: "0", to: "9" }]);
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for simple grammar 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { charClass, literal } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for simple grammar 3`] = `
[
  "test_hello",
  "test_number",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for simple grammar 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for complex grammar 1`] = `
"import type { Parser } from "tpeg-core";import { charClass, choice, literal, oneOrMore, optional, sequence } from "tpeg-core";
/**
 * Generated TPEG Parser: ComplexGrammar
 * 
 * This file was automatically generated from a TPEG grammar.
 * Do not edit this file directly - regenerate from the grammar instead.
 */
export const complex_digit: Parser<any> = charClass([{ from: "0", to: "9" }]);
export const complex_letter: Parser<any> = charClass([{ from: "a", to: "z" }]);
export const complex_word: Parser<any> = oneOrMore(charClass([{ from: "a", to: "z" }]));
export const complex_expression: Parser<any> = memoize(sequence(complex_word, optional(literal(" ")), complex_word));
// contains recursionexport const complex_number: Parser<any> = choice(oneOrMore(charClass([{ from: "0", to: "9" }])), sequence(oneOrMore(charClass([{ from: "0", to: "9" }])), literal("."), oneOrMore(charClass([{ from: "0", to: "9" }]))));
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for complex grammar 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { charClass, choice, literal, oneOrMore, optional, sequence } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for complex grammar 3`] = `
[
  "complex_digit",
  "complex_letter",
  "complex_word",
  "complex_expression",
  "complex_number",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code for complex grammar 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent optimized code 1`] = `
"import type { Parser } from "tpeg-core";import { choice, literal, sequence, zeroOrMore } from "tpeg-core";
// Performance optimizations
import { globalPerformanceMonitor } from "tpeg-generator";
/**
 * Generated TPEG Parser: OptimizedGrammar
 * 
 * This file was automatically generated from a TPEG grammar.
 * Do not edit this file directly - regenerate from the grammar instead.
 */
export const opt_recursive: Parser<any> = memoize(choice(literal("a"), sequence(literal("("), opt_recursive, literal(")"))));
// contains recursionexport const opt_highComplexity: Parser<any> = zeroOrMore(choice(literal("x"), literal("y"), literal("z")));


// Performance monitoring exports
export { globalPerformanceMonitor };"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent optimized code 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { choice, literal, sequence, zeroOrMore } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent optimized code 3`] = `
[
  "opt_recursive",
  "opt_highComplexity",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent optimized code 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without types 1`] = `
"import type { Parser } from "tpeg-core";import { choice, literal } from "tpeg-core";
export const notypes_simple = literal("value");
export const notypes_choice = choice(literal("a"), literal("b"));
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without types 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { choice, literal } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without types 3`] = `
[
  "notypes_simple",
  "notypes_choice",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without types 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without imports 1`] = `
"export const noimports_basic: Parser<any> = literal("test");
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without imports 2`] = `[]`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without imports 3`] = `
[
  "noimports_basic",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code without imports 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with custom name prefix 1`] = `
"import type { Parser } from "tpeg-core";import { literal, sequence } from "tpeg-core";
export const custom_prefix_rule1: Parser<any> = literal("value1");
export const custom_prefix_rule2: Parser<any> = literal("value2");
export const custom_prefix_rule3: Parser<any> = memoize(sequence(custom_prefix_rule1, literal(" "), custom_prefix_rule2));
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with custom name prefix 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { literal, sequence } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with custom name prefix 3`] = `
[
  "custom_prefix_rule1",
  "custom_prefix_rule2",
  "custom_prefix_rule3",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with custom name prefix 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with quantified expressions 1`] = `
"import type { Parser } from "tpeg-core";import { literal, optional, quantified } from "tpeg-core";
export const quant_exactly3: Parser<any> = quantified(literal("a"), 3, 3);
export const quant_range2to5: Parser<any> = quantified(literal("b"), 2, 5);
export const quant_minimum3: Parser<any> = quantified(literal("c"), 3);
export const quant_optional: Parser<any> = optional(literal("d"));
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with quantified expressions 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { literal, optional, quantified } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with quantified expressions 3`] = `
[
  "quant_exactly3",
  "quant_range2to5",
  "quant_minimum3",
  "quant_optional",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with quantified expressions 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with lookahead expressions 1`] = `
"import type { Parser } from "tpeg-core";import { andPredicate, literal, notPredicate } from "tpeg-core";
export const lookahead_positive: Parser<any> = andPredicate(literal("a"));
export const lookahead_negative: Parser<any> = notPredicate(literal("b"));
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with lookahead expressions 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { andPredicate, literal, notPredicate } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with lookahead expressions 3`] = `
[
  "lookahead_positive",
  "lookahead_negative",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with lookahead expressions 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with labeled expressions 1`] = `
"import type { Parser } from "tpeg-core";import { literal } from "tpeg-core";
export const labeled_labeled: Parser<any> = /* label: test_label */ literal("value");
"
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with labeled expressions 2`] = `
[
  "import type { Parser } from "tpeg-core";",
  "import { literal } from "tpeg-core";",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with labeled expressions 3`] = `
[
  "labeled_labeled",
]
`;

exports[`EtaTPEGCodeGenerator Snapshot Tests should generate consistent code with labeled expressions 4`] = `
{
  "estimatedComplexity": "low",
  "optimizationSuggestions": [],
  "templateEngine": "eta",
}
`;
